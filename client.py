# following imports are required by PKI
import Crypto
import Crypto.Random
from Crypto.PublicKey import RSA
import binascii
from xmlrpc.client import Boolean
from Crypto.Hash import SHA256
import hashlib
from Crypto.Signature.pkcs1_15 import PKCS115_SigScheme

## Client class definition
class Client:
   def __init__(self) -> None:
      '''takes no inputs and does not return anything, but instantiates a client object'''
      self.__keyPair = RSA.generate(bits=1024)
      self.__public_key = self.__keyPair.publickey()
      self.__balance = 0
      
   @property
   def identity(self) -> str:
      '''takes no inputs, returns the clients public_key as identity property'''
      return binascii.hexlify(self.__public_key.exportKey(format='DER')).decode('ascii')
   
   # accessors
   def get_key(self) -> list:
      '''takes no inputs, returns a list with items in this order: __keyPair, __public_key'''
      return self.__keyPair, self.__public_key
      
   def retrieve_balance(self) -> float:
      '''takes no inputs, returns the client's balance as float'''
      return self.__balance
   
   # mutators
   def change_balance(self, amount: float) -> None:
      '''takes amount as float and changes clients' balance accordingly, does not return anything'''
      self.__balance += amount

   def trunc_identity(self) -> str:
      '''takes no inputs, returns a string with the truncated id'''
      first7 = self.identity[0:7]
      last7 = self.identity[-7:]
      return f'{first7}...{last7}'
   
   # mining 
   def verify_transaction(self, client: object, transaction: object, signature: str) -> Boolean:
      '''takes a client object, a transaction object and a signature string, returns True in case of success, False otherwise'''
      # testing for equality of the hash signed by the sender against the hash generated by the miner using senderâ€™s public key
      hash = SHA256.new(str(transaction.transaction_info_collector()).encode('utf8')) 
      verifier = PKCS115_SigScheme(client.get_key()[1])

      try:
         verifier.verify(hash, signature) # verify whether hashes match
         print("Signature is valid.")
         if client.retrieve_balance() >= transaction.transaction_info_collector()['value']: # additional duty of miner to check whether sender's balance is sufficient
            print('Balance sufficient.')
            return True
         else:
            print('Balance insufficient.')
            return False
      except:
         print("Signature is invalid.")
         return False

   def mine(self, block: object, difficulty=1) -> str: 
      '''takes a block object and difficulty int (optional), returns a hash string'''
      def sha256(block):
         return hashlib.sha256(block.encode('ascii')).hexdigest()
      assert difficulty >= 1
      prefix = '1' * difficulty
      for i in range(1000000):
         digest = sha256(str(hash(block)) + str(i))
         if digest.startswith(prefix):
            print ("after " + str(i) + " iterations found nonce: "+ digest)
            return digest