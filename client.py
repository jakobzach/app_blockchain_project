# following imports are required by PKI
import Crypto
import Crypto.Random
from Crypto.PublicKey import RSA
import binascii
from xmlrpc.client import Boolean
from Crypto.Hash import SHA256
import hashlib
from Crypto.Signature.pkcs1_15 import PKCS115_SigScheme

## Client class definition
class Client:
   def __init__(self):
      self.keyPair = RSA.generate(bits=1024)
      self.__public_key = self.keyPair.publickey()
      self.__balance = 0
      
   @property
   def identity(self):
      return binascii.hexlify(self.__public_key.exportKey(format='DER')).decode('ascii')
   
   # accessor
   def get_key(self):
      return self.keyPair, self.__public_key
      
   def retrieve_balance(self) -> float:
      return self.__balance
   
   def change_balance(self, amount: float) -> None:
      self.__balance += amount

   def verify_transaction(self, client: object, transaction: object, signature: str) -> Boolean:

        # testing for equality the hash provided by the sender against the hash generated by the miner using senderâ€™s public key
        hash = SHA256.new(str(transaction.transaction_info_collector()).encode('utf8')) 
        verifier = PKCS115_SigScheme(client.get_key()[1])

        try:
            verifier.verify(hash, signature)
            print("Signature is valid.")
            if client.retrieve_balance() >= transaction.transaction_info_collector()['value']:
               print('Balance sufficient.')
               return True
            else:
               print('Balance insufficient.')
        except:
            print("Signature is invalid.")
            return False

   def mine(self, block: object, difficulty=1) -> str:
      def sha256(block):
         return hashlib.sha256(block.encode('ascii')).hexdigest()
      assert difficulty >= 1
      prefix = '1' * difficulty
      for i in range(1000):
         digest = sha256(str(hash(block)) + str(i))
         if digest.startswith(prefix):
            print ("after " + str(i) + " iterations found nonce: "+ digest)
            return digest